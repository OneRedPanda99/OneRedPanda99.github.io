<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-touch-fullscreen" content="yes">
    <title>‚ö° Letter & Symbol Collector</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        html, body {
            height: 100%;
            overflow: hidden;
            position: fixed;
            width: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            padding: 15px;
            width: 100%;
            height: 100%;
            max-width: 1024px;
            max-height: 768px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .header {
            text-align: center;
            margin-bottom: 15px;
            flex-shrink: 0;
        }

        .title {
            font-size: 1.4rem;
            color: #333;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 5px;
        }

        .subtitle {
            color: #666;
            font-size: 0.9rem;
        }

        .stats-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
            flex-shrink: 0;
        }

        .stat-card {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: 8px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid #dee2e6;
        }

        .stat-number {
            font-size: 1.2rem;
            font-weight: bold;
            color: #667eea;
            display: block;
        }

        .stat-label {
            color: #666;
            font-size: 0.7rem;
            margin-top: 2px;
        }

        .category-selector {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            flex-shrink: 0;
            flex-wrap: wrap;
        }

        .category-btn {
            flex: 1;
            min-width: 70px;
            padding: 8px;
            border: 2px solid #667eea;
            border-radius: 6px;
            background: white;
            color: #667eea;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .category-btn.active {
            background: #667eea;
            color: white;
        }

        .current-char {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            margin-bottom: 15px;
            flex-shrink: 0;
            position: relative;
        }

        .char-display {
            font-size: 4rem;
            font-weight: bold;
            margin-bottom: 5px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            font-family: 'Courier New', monospace;
        }

        .char-info {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .progress-ring {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
        }

        .progress-circle {
            transform: rotate(-90deg);
        }

        .canvas-container {
            border: 3px solid #28a745;
            border-radius: 12px;
            margin-bottom: 15px;
            background: white;
            position: relative;
            overflow: hidden;
            flex: 1;
            min-height: 200px;
        }

        #drawingCanvas, #guidelineCanvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            touch-action: none;
        }

        .guidelines {
            pointer-events: none;
            opacity: 0.25;
        }

        .speed-controls {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr;
            gap: 10px;
            margin-bottom: 10px;
            flex-shrink: 0;
        }

        .btn {
            padding: 14px;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            touch-action: manipulation;
        }

        .btn-next {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
            font-size: 1.1rem;
        }

        .btn-skip {
            background: #ffc107;
            color: #212529;
        }

        .btn-clear {
            background: #6c757d;
            color: white;
        }

        .btn:active {
            transform: scale(0.98);
        }

        .character-grid {
            display: grid;
            grid-template-columns: repeat(13, 1fr);
            gap: 3px;
            margin-bottom: 10px;
            flex-shrink: 0;
            max-height: 80px;
            overflow-y: auto;
        }

        .char-box {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: bold;
            border-radius: 4px;
            border: 1px solid #ddd;
            background: white;
            color: #666;
            font-family: 'Courier New', monospace;
        }

        .char-box.completed {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
            border-color: #28a745;
        }

        .char-box.current {
            background: linear-gradient(45deg, #ffc107, #fd7e14);
            color: #212529;
            border-color: #ffc107;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .speed-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(40, 167, 69, 0.9);
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: 600;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .speed-indicator.show {
            opacity: 1;
        }

        .collection-mode {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
            flex-shrink: 0;
        }

        .mode-btn {
            flex: 1;
            padding: 8px;
            border: 2px solid #28a745;
            border-radius: 6px;
            background: white;
            color: #28a745;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
        }

        .mode-btn.active {
            background: #28a745;
            color: white;
        }

        .export-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            flex-shrink: 0;
        }

        .btn-export {
            background: #6c757d;
            color: white;
        }

        .btn-reset {
            background: #dc3545;
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">‚ö° Letter & Symbol Collector</h1>
            <p class="subtitle">Collect handwriting data for all characters</p>
        </div>

        <div class="stats-row">
            <div class="stat-card">
                <span class="stat-number" id="totalCollected">0</span>
                <div class="stat-label">Collected</div>
            </div>
            <div class="stat-card">
                <span class="stat-number" id="currentStreak">0</span>
                <div class="stat-label">Streak üî•</div>
            </div>
            <div class="stat-card">
                <span class="stat-number" id="charsPerMin">0</span>
                <div class="stat-label">Chars/Min</div>
            </div>
            <div class="stat-card">
                <span class="stat-number" id="completion">0%</span>
                <div class="stat-label">Complete</div>
            </div>
        </div>

        <div class="collection-mode">
            <button class="mode-btn active" id="sequentialMode">üìù Sequential</button>
            <button class="mode-btn" id="randomMode">üé≤ Random</button>
            <button class="mode-btn" id="focusMode">üéØ Missing</button>
        </div>

        <div class="category-selector">
            <button class="category-btn active" id="uppercaseBtn">ABC</button>
            <button class="category-btn" id="lowercaseBtn">abc</button>
            <button class="category-btn" id="numbersBtn">123</button>
            <button class="category-btn" id="symbolsBtn">!@#</button>
            <button class="category-btn" id="punctBtn">.,?</button>
            <button class="category-btn" id="mathBtn">¬±√ó√∑</button>
        </div>

        <div class="current-char">
            <div class="char-display" id="currentChar">A</div>
            <div class="char-info" id="charInfo">Uppercase Letter ‚Ä¢ 0/5 samples</div>
            <div class="progress-ring">
                <svg class="progress-circle" width="40" height="40">
                    <circle cx="20" cy="20" r="16" fill="none" stroke="#ffffff50" stroke-width="3"/>
                    <circle cx="20" cy="20" r="16" fill="none" stroke="white" stroke-width="3" 
                            stroke-dasharray="100" stroke-dashoffset="100" id="progressCircle"/>
                </svg>
            </div>
            <div class="speed-indicator" id="speedIndicator">‚ö° Fast!</div>
        </div>

        <div class="character-grid" id="characterGrid">
            <!-- Characters will be populated by JavaScript -->
        </div>

        <div class="canvas-container" id="canvasContainer">
            <canvas id="drawingCanvas"></canvas>
            <canvas class="guidelines" id="guidelineCanvas"></canvas>
        </div>

        <div class="speed-controls">
            <button class="btn btn-next" id="nextBtn">‚úÖ Next Character (Space)</button>
            <button class="btn btn-skip" id="skipBtn">‚è≠Ô∏è Skip</button>
            <button class="btn btn-clear" id="clearBtn">üóëÔ∏è Clear</button>
        </div>

        <div class="export-controls">
            <button class="btn btn-export" id="exportBtn">üì§ Export Data</button>
            <button class="btn btn-reset" id="resetBtn">üîÑ Reset All</button>
        </div>
    </div>

    <script>
        // Global variables
        let canvas, ctx, guidelineCanvas, guidelineCtx;
        let isDrawing = false;
        let currentStroke = [];
        let allStrokes = [];
        let sampleData = [];
        
        // Collection tracking
        let collectionMode = 'sequential';
        let currentCategory = 'uppercase';
        let currentCharIndex = 0;
        let charCounts = {};
        let targetPerChar = 5;
        let startTime = Date.now();
        let lastCharTime = Date.now();
        let streak = 0;
        let totalCollected = 0;

        // Character sets
        const characterSets = {
            uppercase: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'],
            lowercase: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'],
            numbers: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
            symbols: ['!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '-', '_', '+', '='],
            punct: ['.', ',', '?', '!', ';', ':', '"', "'", '/', '\\', '[', ']', '{', '}'],
            math: ['+', '-', '=', '√ó', '√∑', '¬±', '‚àû', '‚àö', '^', '¬∞', '<', '>']
        };

        // Get all characters
        const allCharacters = [
            ...characterSets.uppercase,
            ...characterSets.lowercase,
            ...characterSets.numbers,
            ...characterSets.symbols,
            ...characterSets.punct,
            ...characterSets.math
        ];

        // Initialize character counts
        allCharacters.forEach(char => charCounts[char] = 0);

        function init() {
            canvas = document.getElementById('drawingCanvas');
            ctx = canvas.getContext('2d');
            guidelineCanvas = document.getElementById('guidelineCanvas');
            guidelineCtx = guidelineCanvas.getContext('2d');

            resizeCanvas();
            setupCanvas();
            drawGuidelines();
            setupEventListeners();
            setupCharacterGrid();
            updateCurrentChar();
            updateStats();
        }

        function setupEventListeners() {
            // Canvas events
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);

            // Button events
            document.getElementById('nextBtn').addEventListener('click', nextChar);
            document.getElementById('skipBtn').addEventListener('click', skipChar);
            document.getElementById('clearBtn').addEventListener('click', clearCanvas);
            document.getElementById('exportBtn').addEventListener('click', exportData);
            document.getElementById('resetBtn').addEventListener('click', resetData);

            // Mode buttons
            document.getElementById('sequentialMode').addEventListener('click', () => setMode('sequential'));
            document.getElementById('randomMode').addEventListener('click', () => setMode('random'));
            document.getElementById('focusMode').addEventListener('click', () => setMode('focus'));

            // Category buttons
            document.getElementById('uppercaseBtn').addEventListener('click', () => setCategory('uppercase'));
            document.getElementById('lowercaseBtn').addEventListener('click', () => setCategory('lowercase'));
            document.getElementById('numbersBtn').addEventListener('click', () => setCategory('numbers'));
            document.getElementById('symbolsBtn').addEventListener('click', () => setCategory('symbols'));
            document.getElementById('punctBtn').addEventListener('click', () => setCategory('punct'));
            document.getElementById('mathBtn').addEventListener('click', () => setCategory('math'));

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space') {
                    e.preventDefault();
                    nextChar();
                } else if (e.code === 'KeyC') {
                    clearCanvas();
                } else if (e.code === 'KeyS') {
                    skipChar();
                }
            });

            // Prevent scrolling
            document.addEventListener('touchstart', (e) => {
                if (e.target === canvas) e.preventDefault();
            }, { passive: false });
            document.addEventListener('touchmove', (e) => {
                if (e.target === canvas) e.preventDefault();
            }, { passive: false });

            window.addEventListener('orientationchange', () => {
                setTimeout(() => {
                    resizeCanvas();
                    drawGuidelines();
                }, 200);
            });
        }

        function setMode(mode) {
            collectionMode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(mode + 'Mode').classList.add('active');
            updateCurrentChar();
            updateCharacterGrid();
        }

        function setCategory(category) {
            currentCategory = category;
            currentCharIndex = 0;
            
            document.querySelectorAll('.category-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(category + 'Btn').classList.add('active');
            
            updateCurrentChar();
            updateCharacterGrid();
        }

        function setupCharacterGrid() {
            const container = document.getElementById('characterGrid');
            container.innerHTML = '';
            
            const displayChars = characterSets[currentCategory];
            displayChars.forEach(char => {
                const box = document.createElement('div');
                box.className = 'char-box';
                box.textContent = char;
                box.id = `char-${char.charCodeAt(0)}`;
                container.appendChild(box);
            });
        }

        function updateCharacterGrid() {
            setupCharacterGrid();
            
            const displayChars = characterSets[currentCategory];
            displayChars.forEach(char => {
                const box = document.getElementById(`char-${char.charCodeAt(0)}`);
                if (!box) return;
                
                const count = charCounts[char] || 0;
                box.classList.remove('completed', 'current');
                
                if (count >= targetPerChar) {
                    box.classList.add('completed');
                } else if (char === getCurrentChar()) {
                    box.classList.add('current');
                }
            });
        }

        function getCurrentChar() {
            const categoryChars = characterSets[currentCategory];
            
            switch (collectionMode) {
                case 'sequential':
                    return categoryChars[currentCharIndex % categoryChars.length];
                
                case 'random':
                    return categoryChars[Math.floor(Math.random() * categoryChars.length)];
                
                case 'focus':
                    const incompleteChar = categoryChars.find(char => 
                        (charCounts[char] || 0) < targetPerChar
                    );
                    return incompleteChar || categoryChars[0];
                
                default:
                    return categoryChars[0];
            }
        }

        function updateCurrentChar() {
            const char = getCurrentChar();
            const count = charCounts[char] || 0;
            
            // Determine character type
            let charType = '';
            if (/[A-Z]/.test(char)) charType = 'Uppercase Letter';
            else if (/[a-z]/.test(char)) charType = 'Lowercase Letter';
            else if (/[0-9]/.test(char)) charType = 'Number';
            else if (/[!@#$%^&*()_+=\-]/.test(char)) charType = 'Symbol';
            else if (/[.,:;"'?!\/\\[\]{}]/.test(char)) charType = 'Punctuation';
            else if (/[+\-=√ó√∑¬±‚àû‚àö^¬∞<>]/.test(char)) charType = 'Math Symbol';
            else charType = 'Special Character';
            
            document.getElementById('currentChar').textContent = char;
            document.getElementById('charInfo').textContent = 
                `${charType} ‚Ä¢ ${count}/${targetPerChar} samples`;
            
            // Update progress circle
            const progress = Math.min(count / targetPerChar * 100, 100);
            const circumference = 2 * Math.PI * 16;
            const offset = circumference - (progress / 100) * circumference;
            document.getElementById('progressCircle').style.strokeDashoffset = offset;
        }

        function nextChar() {
            if (allStrokes.length === 0) {
                showSpeedFeedback('‚úçÔ∏è Write the character first!');
                return;
            }

            const currentChar = getCurrentChar();
            
            // Save sample
            sampleData.push({
                text: currentChar,
                strokes: allStrokes.map(stroke => stroke.map(point => [point.x, point.y])),
                timestamp: Date.now(),
                category: currentCategory,
                mode: 'character'
            });

            // Update counts
            charCounts[currentChar] = (charCounts[currentChar] || 0) + 1;
            totalCollected++;

            // Speed tracking
            const now = Date.now();
            const timeDiff = (now - lastCharTime) / 1000;
            if (timeDiff < 10) {
                streak++;
                showSpeedFeedback(`üî• Streak: ${streak}!`);
            } else {
                streak = 0;
            }
            lastCharTime = now;

            // Advance to next character
            if (collectionMode === 'sequential') {
                currentCharIndex++;
            }

            clearCanvas();
            updateCurrentChar();
            updateCharacterGrid();
            updateStats();
        }

        function skipChar() {
            if (collectionMode === 'sequential') {
                currentCharIndex++;
            }
            updateCurrentChar();
            updateCharacterGrid();
            showSpeedFeedback('‚è≠Ô∏è Skipped');
        }

        function showSpeedFeedback(message) {
            const indicator = document.getElementById('speedIndicator');
            indicator.textContent = message;
            indicator.classList.add('show');
            setTimeout(() => indicator.classList.remove('show'), 1500);
        }

        function updateStats() {
            document.getElementById('totalCollected').textContent = totalCollected;
            document.getElementById('currentStreak').textContent = streak;
            
            const sessionMinutes = (Date.now() - startTime) / 60000;
            const charsPerMin = sessionMinutes > 0 ? Math.round(totalCollected / sessionMinutes) : 0;
            document.getElementById('charsPerMin').textContent = charsPerMin;
            
            // Calculate completion percentage
            const totalPossible = allCharacters.length * targetPerChar;
            const totalCompleted = Object.values(charCounts).reduce((sum, count) => sum + Math.min(count, targetPerChar), 0);
            const completion = Math.round((totalCompleted / totalPossible) * 100);
            document.getElementById('completion').textContent = completion + '%';
        }

        function exportData() {
            if (sampleData.length === 0) {
                alert('No data to export! Collect some samples first.');
                return;
            }

            const exportData = {
                metadata: {
                    totalSamples: sampleData.length,
                    charCounts: charCounts,
                    createdAt: new Date().toISOString(),
                    version: '1.0',
                    device: navigator.userAgent.includes('iPad') ? 'iPad' : 'Unknown',
                    targetPerChar: targetPerChar,
                    categories: Object.keys(characterSets)
                },
                samples: sampleData
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `letter_symbol_data_${Date.now()}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            const fileSizeKB = Math.round(dataStr.length / 1024);
            alert(`‚úÖ Exported ${sampleData.length} character samples!\nüìÅ File size: ${fileSizeKB}KB`);
        }

        function resetData() {
            if (confirm('Reset all collected data? This cannot be undone.')) {
                sampleData = [];
                allCharacters.forEach(char => charCounts[char] = 0);
                totalCollected = 0;
                streak = 0;
                startTime = Date.now();
                updateCurrentChar();
                updateCharacterGrid();
                updateStats();
                showSpeedFeedback('üîÑ Reset complete');
            }
        }

        // Drawing functions
        function resizeCanvas() {
            const container = document.getElementById('canvasContainer');
            const rect = container.getBoundingClientRect();
            canvas.width = Math.floor(rect.width);
            canvas.height = Math.floor(rect.height);
            guidelineCanvas.width = canvas.width;
            guidelineCanvas.height = canvas.height;
            setupCanvas();
        }

        function setupCanvas() {
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
        }

        function drawGuidelines() {
            guidelineCtx.clearRect(0, 0, guidelineCanvas.width, guidelineCanvas.height);
            
            const height = guidelineCanvas.height;
            const width = guidelineCanvas.width;
            const margin = 40;
            
            guidelineCtx.strokeStyle = '#cccccc';
            guidelineCtx.lineWidth = 1;
            
            // Baseline for character alignment
            const baseline = height * 0.7;
            guidelineCtx.beginPath();
            guidelineCtx.moveTo(margin, baseline);
            guidelineCtx.lineTo(width - margin, baseline);
            guidelineCtx.stroke();
            
            // Center guide for consistent sizing
            const centerX = width / 2;
            guidelineCtx.beginPath();
            guidelineCtx.moveTo(centerX, margin);
            guidelineCtx.lineTo(centerX, height - margin);
            guidelineCtx.stroke();
        }

        function getEventPos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        function handleTouchStart(e) {
            e.preventDefault();
            startDrawing(getEventPos(e));
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (isDrawing) draw(getEventPos(e));
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            stopDrawing();
        }

        function handleMouseDown(e) {
            startDrawing(getEventPos(e));
        }

        function handleMouseMove(e) {
            if (isDrawing) draw(getEventPos(e));
        }

        function handleMouseUp(e) {
            stopDrawing();
        }

        function startDrawing(pos) {
            isDrawing = true;
            currentStroke = [{x: pos.x, y: pos.y, time: Date.now()}];
            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y);
        }

        function draw(pos) {
            if (!isDrawing) return;
            
            if (currentStroke.length > 0) {
                const lastPoint = currentStroke[currentStroke.length - 1];
                const distance = Math.sqrt((pos.x - lastPoint.x) ** 2 + (pos.y - lastPoint.y) ** 2);
                if (distance < 2.0) return;
            }
            
            currentStroke.push({x: pos.x, y: pos.y, time: Date.now()});
            ctx.lineTo(pos.x, pos.y);
            ctx.stroke();
        }

        function stopDrawing() {
            if (!isDrawing) return;
            isDrawing = false;
            
            if (currentStroke.length > 1) {
                allStrokes.push([...currentStroke]);
            }
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            allStrokes = [];
        }

        // Auto-export every 100 characters
        setInterval(() => {
            if (totalCollected > 0 && totalCollected % 100 === 0 && sampleData.length > 0) {
                const autoExportData = {
                    metadata: {
                        totalSamples: sampleData.length,
                        charCounts: charCounts,
                        createdAt: new Date().toISOString(),
                        version: '1.0',
                        device: navigator.userAgent.includes('iPad') ? 'iPad' : 'Unknown',
                        targetPerChar: targetPerChar,
                        autoExport: true
                    },
                    samples: sampleData
                };
                
                const dataStr = JSON.stringify(autoExportData, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                const link = document.createElement('a');
                link.href = URL.createObjectURL(dataBlob);
                link.download = `auto_backup_${Date.now()}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                showSpeedFeedback('üíæ Auto-backup saved!');
            }
        }, 5000);

        // Initialize
        window.addEventListener('load', init);
        setInterval(updateStats, 5000);
    </script>
</body>
</html>
